* In fill_bucket.js (use [http://localhost:9966/debug/index.html](http://localhost:9966/debug/index.html)), modify [this line](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/data/bucket/fill_bucket.js#L142) to add a random integer between 0 and 8192 instead of the x or y coordinate (or try both). Can we explain what this does? (Try zooming to the Croatian islands maybe, where there are lots of interesting polygons with good background contrast color). Zoom in and out; when and why does it change at intervals?
    * When we randomize the X coordinate, we’re moving just one vertex of a polygon by setting it to anywhere from the far left to the far right of the tile. Chances are this is going to be pretty far away from its intended X coordinate, producing the horizontal jagged effect. Same with the Y coordinate. If we randomize the coordinate, then the jaggedness goes all over the place, because one of the polygon’s vertices is anywhere on the tile, probably far from where it should be.

* In fill_extrusion_bucket.js (use [http://localhost:9966/debug/buildings.html](http://localhost:9966/debug/buildings.html)), comment out [this line](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/data/bucket/fill_extrusion_bucket.js#L165), and then change [this](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/data/bucket/fill_extrusion_bucket.js#L168) to add only one instead of two (this is where we keep track of how many triangles we should have in the index array — this is more or less just bookkeeping). Can we explain what’s happening? Why do all the rooftops look intact? How could we make those look just as jagged?
    * When we comment out the first line, we’re removing one out of every two triangles that make up the “walls” of a 3D extrusion (remember, we create a triangle by adding the indices of its vertices in the vertex array to the index array), so in our map, every wall will have only one lower triangle.

* In circle_bucket.js (use [http://localhost:9966/debug/circles.html](http://localhost:9966/debug/circles.html)), [here](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/data/bucket/circle_bucket.js#L145-L146) we add two triangles. What if we changed which indices we made the triangles out of? Change the first line to add triangles at index 0-2-3, then the second to add triangle 0-3-1. Can we explain this? Using [this diagram](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/data/bucket/circle_bucket.js#L131-L135) as a guide, how would you flip the pacman in the opposite direction?
    * We’re still using all the same vertices — which basically make up a square (in the fragment shader we shave off the corners to make it round) — but connecting them wrong. Instead of constructing a lower right and an upper left, we’re now constructing an upper left triangle and a lower left triangle, leaving a slice of the circle unaccounted for. If you wanted to flip the pacman, you could use triangles 0-1-2 and 1-2-3 (note those numbers don’t need to be in order).

* Text is rendered using a method called [“signed distance fields (SDFs),”](https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817) which are essentially rasterized single-channel representations of glyphs, where the value of a given pixel within a glyph is higher the more “inside” the glyph it is, and lower the further outside the glyph it is. We use this value to determine the opacity of a pixel within a glyph “quad” (rectangle) when we sample the SDF raster [here](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/shaders/symbol_sdf.fragment.glsl#L420. If you invert the alpha value [here](https://github.com/mapbox/mapbox-gl-js/blob/78a685240f07c4af6ece224ebd46022e8e60ce1a/src/shaders/symbol_sdf.fragment.glsl#L47) (alpha range is [0, 1]), how does this affect rendering?
    * This will invert text rendering, creating a knockout effect. Note how throughout the fragment shader `color` is generally static: we’re actually filling in the entire quad with that same rgb value, and the visibility of any given pixel depends only on its opacity.
